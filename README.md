# functions
![](/img/functons.jpg)
>Функция JavaScript — это блок кода, предназначенный для выполнения определенной задачи.

Функция JavaScript выполняется, когда «что-то» вызывает ее (вызывает).
## Function – Declaration ##
![](/img/declaration.jpg)
>Идентификатор функции, которому предшествует тип возвращаемого значения и за которым следует список параметров, называется объявлением функции или прототипом функции. Прототип информирует компилятор о формате и существовании функции до ее использования.

>• Функция объявляется с помощью ключевого слова function.
• Основные правила именования функций аналогичны именованию переменных. Это
лучше написать описательное имя для вашей функции. Например, если
используется для сложения двух чисел, вы можете назвать функцию add или
добавить номера.
• Тело функции записывается внутри {}.

![](/img/body%20declaration.webp)
>На предыдущей странице мы объявили функцию с именем
приветствовать(). Чтобы использовать эту функцию, нам нужно вызвать ее.
Вот как вы можете вызвать вышеупомянутую функцию приветствия().

![](/img/ddd.png)
>Функция также может быть объявлена ​​с помощью
параметры. Параметр – это значение, которое
передается при объявлении функции.

![](/img/call.svg)
>Оператор return может использоваться для возврата значения в вызов функции.
Оператор return означает, что функция завершилась. Любой код
после возврата не выполняется.
Если ничего не возвращается, функция возвращает неопределенное значение.

## Function – Expression ##
>Переменная x используется для хранения функции.
Здесь функция трактуется как
выражение. И функция называется
используя имя переменной.
Функция называется анонимной.
функция.
![](/img/exp.jpg)

>Функция в JavaScript – это не магическая языковая структура, а особого типа значение.

Синтаксис, который мы использовали до этого, называется Function Declaration (Объявление Функции):

function sayHi() {
  alert( "Привет" );
}
Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).

Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.

Это выглядит следующим образом:

let sayHi = function() {
  alert( "Привет" );
};
Здесь мы можем видеть переменную sayHi, получающую значение, новую функцию, созданную как function() { alert("Привет"); }.

Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от =), это Function Expression.

Обратите внимание, что после ключевого слова function нет имени. Для Function Expression допускается его отсутствие.

Здесь мы сразу присваиваем её переменной, так что смысл этих примеров кода один и тот же: "создать функцию и поместить её в переменную sayHi".

В более сложных ситуациях, с которыми мы столкнёмся позже, функция может быть создана и немедленно вызвана, или запланирована для дальнейшего выполнения, нигде не сохраняясь, таким образом, оставаясь анонимной.

## Scope ##
>он строит нашу программу, вложенную
набор правил области действия. Первый этаж здания
представляет вашу текущую область действия,
где бы ты ни был. Верхний уровень здания находится
глобальный охват.
![](/img/scope.png)
>Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области твоего кода.

## Scope – Local Scope ##
>Переменная также может иметь локальную область видимости,
к нему можно получить доступ только внутри функции.
В приведенной ниже программе переменная a является
глобальная переменная, а переменная b является локальной
переменная. Доступ к переменной b можно получить
только внутри функции приветствия. Следовательно,
когда мы пытаемся получить доступ к переменной b снаружи
функции возникает ошибка.

![](/img/Scope_fbrzcw.webp)
>Локальная область действия — это характеристика переменных, которая делает их локальными (т. е. имя переменной связано со своим значением только в пределах области действия, которая не является глобальной)
## Hoisting - Variable ##
![](/img/hoisting.jpg)
>Подъем — это механизм JavaScript, в котором объявления переменных и функций перемещаются в верхнюю часть своей области видимости перед выполнением кода. Это неизбежно означает, что независимо от того, где объявлены функции и переменные, они перемещаются в начало своей области действия независимо от того, является ли их область действия глобальной или локальной.
![](/img/R3e336J.png)
>Есть соблазн подумать, что весь код, который вы видите в
JavaScript
программа интерпретируется построчно, сверху вниз, как
программа
выполнять. Хотя это по сути верно, есть одна часть этого
как-
предположение, которое может привести к неправильному мышлению о вашем
программа.


>Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.

Узнаем больше
Пример:
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления. Например:

function catName(name) {
  console.log("Мою кошку зовут " + name);
}

catName("Тигр");
/*
Результатом будет вывод строки: "Мою кошку зовут Тигр"
*/
Copy to Clipboard
Предыдущий пример демонстрирует ожидаемый рабочий код. Теперь давайте посмотрим, что происходит, когда мы вызываем функцию в коде до её объявления:

catName("Раиса");

function catName(name) {
  console.log("Мою кошку зовут " + name);
}
/*
Результатом будет вывод строки: "Мою кошку зовут Раиса"
*/
Copy to Clipboard
Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.

Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

Пример:
num = 6;
num + 7;
var num;
/* не генерирует ошибку, так как num объявлен */
JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после её использования, то значение будет undefined. Два примера ниже демонстрируют это поведение.

var x = 1; // Инициализируем x
console.log(x + " " + y);  // '1 undefined'
var y = 2;
//код выше и код ниже одинаковые

var x = 1; // Инициализируем x
var y; // Объявляем y
console.log(x + " " + y);  // '1 undefined'
y = 2; // Инициализируем y
## Hoisting – Function Declaration ##

![](/img/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.png)
>Подъем — это механизм JavaScript, в котором объявления переменных и функций перемещаются в верхнюю часть своей области видимости перед выполнением кода. Это неизбежно означает, что независимо от того, где объявлены функции и переменные, они перемещаются в начало своей области действия независимо от того, является ли их область действия глобальной или локальной.
![](/img/2465.js52.png)
>Итак, один из способов мыслить, в некотором роде метафорически, об этом процессе таков:
что объявления переменных и функций «перемещаются» оттуда, где они
появляются в потоке кода в верхней части кода. Это приводит к
подъем имени.

## Hoisting – Function Expression ##
>Объявления функций поднимаются, как мы только что видели.
Но функциональные выражения — нет.
![](/img/mmm.png)
>Подъем — это механизм JavaScript, в котором объявления переменных и функций перемещаются в верхнюю часть своей области видимости перед выполнением кода. Это неизбежно означает, что независимо от того, где объявлены функции и переменные, они перемещаются в начало своей области действия независимо от того, является ли их область действия глобальной или локальной.
>Идентификатор переменной foo поднимается и прикрепляется к закрывающему
scope(global) этой программы, поэтому foo() не выдает ошибку ReferenceError.


Но foo еще не имеет значения (как если бы это была истинная функция
объявление вместо выражения). Итак, foo() пытается вызвать
неопределенное значение, которое является недопустимой операцией Type Error.


## Recursion ##
![](/img/maxresdefault.jpg)
>Рекурсия — это процесс вызова самого себя. Функция, которая
вызывает сама себя, называется рекурсивной функцией.
Синтаксис рекурсивной функции:
![](/img/rec.png)
>
Рекурсивная функция должна иметь условие для прекращения вызова самой себя. В противном случае,
функция вызывается бесконечно.
Как только условие выполнено, функция перестает вызывать себя. Это называется
базовое состояние.
Чтобы предотвратить бесконечную рекурсию, вы можете использовать оператор if...else (или аналогичный
подход), где одна ветвь делает рекурсивный вызов, а другая
нет.

## Closure ##
>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

![](/img/clos.png)
>Закрытие является одним из самых
важно, а часто и наименее
понятно, понятия в
JavaScript. Вы можете думать о
закрытие как способ
«вспомнить» и продолжать
получить доступ к области действия функции (ее
переменные) даже после того, как
функция завершила работу.

![](/img/bbb.png)